# 题目 01- 请你说一说什么是线程和进程？
## 线程 & 进程
一个进程占用一个pid，一个线程是操作系统的最小调度单位 
从linux内核的角度，线程和进程没有本质的区别，最早时期是没有线程概念的，只有进程。进程是有父进程fork出来的，有单独的内存空间、文件系统、打开的文件、信号量等信息 
随着科技的进步，出现了线程的概念，操作系统为了解决线程的问题，在原有进程上做了改进，同样是创建一个新的进程，但是该进程和原有进程使用同一个pid、内存空间等

## 上下文切换（线程 & 进程）
进程的上线文切换包括内存空间的切换全局页表目录、切换内核态堆栈信息、切换硬件上下文、刷新TLB、切换系统调度器的执行代码，以及间接开销（cpu缓存失效）
线程的上下文切换本质上仍然是进程的切换，只是共享了虚拟地址空间，主要节省了虚拟地址空间的切换，但仍然需要同调度切换

## 并发 & 并行
并发是指一段时间内有多个任务在执行，但是同一时间内只有一个任务在执行
并行是指同一时间内有多个任务并行执行

# 题目 02- 使用了多线程会带来什么问题呢？
# 多线程问题
可见性问题、原子性问题、有序性问题，主要就是线程安全问题
## 能不能详细说说线程安全问题
多个线程同时访问一个共享变量，运行结果与预期不一致
## 原子性、有序性和可见性能不能深入的谈一下
原子性：一个线程对于共享内存的操作，要么成功要么失败，不存在中间状态
有序性：对于一个共享变量的操作，遵循顺序性，不做指令重排序
可见性：一个线程对于共享变量的修改，对于其他线程可见

# 题目 03- 什么是死锁？如何排查死锁?
死锁的必要条件：
    （1）对一个共享资源，同一时刻只有一个线程可以获取
    （2）如果已经获取共享资源，在未完成业务操作时，不会释放
    （3）对于有其他线程已经在使用共享资源的情况下，希望获取资源的线程会一直等待
    （4）多个线程和对于多个资源造成了循环等待
排查：
    （1）使用jstack排查，可以看到deadlock信息
    （2）使用jvm监控平台也可以查看
    （3）使用jvm自带的工具可以查看，例如jconsal等
    （4）利用三方工具也可以查看，例如easyGC、Arthus等


# 题目 04- 请你说一说 synchronized 和 volatile 的原理与区别
synchronzied：可重入锁，可以解决并发中可见性、原子性，可使用到类、方法、代码块、对象等
    锁升级：
        无锁：当没有线程竞争时，JIT编译器会对锁进行优化，做锁消除，达到无锁状态
        偏向锁：对象头中有MarkWork，存的是锁信息，hashcode、GC年龄等，对象刚创建时markword中持有该对象的线程id为空，如果一个线程要加锁，直接替换markwork的线程id，置换成功后则获取锁
        轻量级锁：如果在偏向锁中替换线程id失败，说明存在线程竞争，会转入自旋锁，使用自旋替换的方式。在jvm中使用的是自适应偏向锁，会自适应做自旋次数，根据历史的自旋次数选择合适的自旋次数
        重量级锁：如果经过指定次数的自旋失败后还没有获取到锁，则升级为重量级锁，重量级锁使用的是操作系统的mutexLock
volatile：主要作用是保证内存可见和防止指令重排序，解决并发中可见性和有序性的问题，不能解决原子性问题
    volatile主要使用的是内存屏障，在写前增加storestore屏障，在写后增加storeload屏障，在读前添加loadload屏障，在读后添加loadstore屏障

## 什么是 JMM 内存模型？
线程运行时，为了提高效率，将数据存在本地内存（CPU内存），该内存是线程独享的，其他线程不可见，共享内存是存在内存中的，这就需要考虑线程间对于共享变量的数据同步
线程间数据同步可以使用消息、主内存等方式，在java中主要使用了主内存同步的方式。
Java内存模型规定所有的变量都存储在主内存中，包括实例变量，静态变量，但是不包括局部变量和方法参数。每个线程都有自己的工作内存，线程的工作内存保存了该线程用到的变量和主内存的副本拷贝，线程对变量的操作都在工作内存中进行。线程不能直接读写主内存中的变量。

## 什么是 happens-before 规则？
在代码编译和代码运行期间，操作系统为了提高执行效率，都会做指令重排序，但是指令重排序遵循serial-as-if，即无论如何重排序，在单线程条件下，运行结果不会发生改变
但是在多线程情况下，指令重排序会导致执行结果与预期不一致，为了解决这个问题，提出了happen-before规则，用于屏蔽操作系统和代码的具体实现，操作系统在happen-before规则下，怎么优化都可以，应用程序只要遵循happen-before就不会出现问题
happen-bofore具体内容：
    1、锁：一个unlock操作优先于后面对该对象的lock操作
    2、volatile：对于volatile修饰的变量的写优先于后续对于该变量的写
    3、代码顺序规则：在同一个线程内，代码的执行顺序与代码的书写顺序一致
    4、传递规则：A happen-before B，B happen-before C，那么A happen-before C
    5、线程启动：线程的start方法先于此线程的其他动作
    6、线程中断：对县城interrupt方法的调用优先于中断事件的处理
    7、线程终结：线程中所有的操作都优先于线程终止操作
    8、对象终结：一个对象的初始化完成优先于finalize方法

# 题目 05- 为什么使用线程池？如何创建线程池？

## 为什么要使用线程池
1、为了更好的管理资源，防止线程创建过多
2、为了更好的效率，线程的创建非常消耗资源，使用线程池可以复用线程资源

## 手动创建和自动创建线程池都需要介绍
自动创建线程池：
    （1）newFixedThreadPool：固定线程数线程池，使用的无界阻塞队列LinkedBlockingQueue，适用于一般的业务场景
    （2）newSingleThreadPool：单一线程的线程池，使用的是无界阻塞队列LinkedBlockingQueue，适用于快速响应，
    （3）newCachedThreadPool：具有缓存特性的线程池，使用的是单一阻塞队列SynchronBlockingQueue，最小线程数为0，最大线程数为int的最大值，适用于RT时间短、并发高的场景
    （4）newScheduleThreadPool：具有延时特性的线程池，使用的是双端演示队列DeleyQueue，适用于定时任务或者周期性执行的任务，很多定时任务框架的底层实现方案
手动创建线程池：
    使用线程池构造函数，参数有七个：核心线程数、阻塞队列、最大线程数、线程存活时间、线程存活时间单位、线程工厂、拒绝策略
    拒绝策略：抛出异常、丢弃任务、丢弃最早的任务、使用主线程执行
## 最好介绍一下线程池的实现原理
1、任务提交流程：提交任务时，判断当前线程数是否小于核心线程数：
    如果小于核心线程数：创建线程执行
    如果大于等于核心线程数：判断阻塞队列是否已满
        如果未满：将任务添加到阻塞队列
        如果已满：判断当前线程数是否小于最大线程数
            如果小于最大线程数：创建新的线程执行
            如果大于等于最大线程数：按照拒绝策略处理
2、获取任务流程：当线程执行完成后，会从阻塞队列获取任务继续执行，使用的take方法，传递的是线程存活时间，判断阻塞队列中是否可以获取任务：
    如果阻塞队列中有任务：直接获取任务执行
    如果阻塞队列中没有任务：take会阻塞获取，如果超过阻塞时间还没有新的任务，需要判断当前线程数与核心线程数对比
        如果大于核心线程数：则会销毁线程，这个销毁需要保证线程安全
        如果小于等于核心线程数：则继续阻塞等待
3、停止流程：线程池提供了shutdown和shutdownnow两个方法，调用不同的方法会将状态设置为对应的状态，当一个线程执行完任务后，会从阻塞队列获取任务，获取前会判断当前的状态：
    shutdown状态：仍然会去阻塞队列获取任务，直到阻塞队列中没有任务时，会销毁线程
    shutdownnow状态：不会再去阻塞队列获取任务，直接销毁线程



# 题目 06-ThreadLocal 中 Map 的 key 为什么要使用弱引用？
## key为什么要用弱引用
1、防止ThreadLocal对象该回收却不被回收：防止线程在使用ThreadLocal对象完后，该对象本应该是处于垃圾收集器收集范围内，却因为线程的threadLocals属性还持有ThreadLocal对象的强引用，导致无法被回收，引起内存泄漏，如果线程是线程池，生命周期比较长，那么可能会因为内存泄漏造成严重的后果，所以采用了弱引用，在使用ThreadLocal对象完后，会在下一次垃圾回收被放入回收范围内
2、给回收value创造筛选条件key是虚引用，value是强引用，有可能出现ThreadLocal对象被回收后出现key为null，而value又是强引用的情况，不做其他处理的话，线程未结束之前不会对其进行回收，，这也就导致了内存泄漏。为了对这些过期的键值对进行回收，ThreadLocal类在set、get、remove方法中都会去清理过期的键值对。判断过期的键值对，就是根据key为null。

## 阿里 Java 开发手册中，为什么说不清理自定义的 ThreadLocal 变量会导致内存泄露呢？
key是弱引用，在GC时就会被回收，value是强引用，是与线程绑定的，如果使用的是线程池或者线程一只存在，就会发生内存泄漏问题