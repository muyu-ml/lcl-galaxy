# Java 运行时数据区介绍
1、堆：
    线程共享
    主要存储运行时创建的对象，是垃圾回收的主要区域
    分为年轻代、老年代，比例为1：2，年轻代又分为Eden区和S区（S0和S1），比例8：2

2、虚拟机栈：
    线程独享
    用来存储栈针信息，每个栈针包含局部变量表、操作数栈、动态链接、返回地址等，如果是虚拟机栈的栈针，那么程序计数器存储的是指令地址

3、本地方法栈：
    线程独享
    JVM中调用C语言库的方法时（Native方法），会将栈针压入本地方法栈，在程序计数器中存储为null

4、方法区：
    线程共享
    存储的是Class类信息、运行时常量池、JIT编译的缓存
    是JVM规范的区域，不同的虚拟机以及虚拟机的不同版本都有不同的实现，如HotSpot1.7和1.8的实现分别是永久代和元空间

5、运行时常量池：
    常量池有class常量池、字符串常量池、运行时常量池
    class常量池：一个class文件有一个class常量池
    运行时常量池：一个class对象有一个运行时常量池
    字符串常量池：存储字符串常量，JDK1.7存储在堆中，JDK1.8存储在元空间中（方法区）
    三者关系：
        java文件被编译成class文件后，class文件除了版本、字段、方法、接口等信息外，还包含一个class常量池，用于存放生成的各种字面量和符号引用
        当类加载完成后，将每个class常量池中的符号引用转为直接引用转到运行时常量池中
        字符串常量池存储的是当前虚拟机的字符串常量
    在方法区中，存在Class文件和运行时常量池，Class文件又包含Class文件信息和class文件常量池
    在jdk1.7之前，字符串常量池存在于方法区中，jdk1.7中，字符串常量池存在于堆中，jdk8方法区的实现改为了元空间
    
    
6、直接内存：
    相对于JVM内存以外的内存，即为直接内存，在java中使用DirectByte作为引用，开辟内存空间效率低，读写效率高，常用语高IO的场景，例如Dubbo

7、为什么要分代
    绝大多数的对象都是朝生熄灭的，但是熬过一定次数的垃圾回收后，被清理的概率就会大大降低，针对这种情况，对堆进行分代，将不同情况的对象放在不同的分代中
    在不同的分代中，根据对象特点，采用不同的垃圾回收算法

# Java对象的声明周期
1、创建过程
    四个创建或初始化场景：
        （1）遇到new、putstatic、getstatic、invoikestatic这四个关键字时，进行初始化
        （2）使用反射初始化
        （3）初始化类时，父类还没有初始化时，先初始化父类
        （4）程序启动时要执行的主类
    常量池检查：检查根据全限定名是否可以在常量池中找到一个类的符号引用，如果没有，则进行类加载，如果存在，判断是否已经加载，如果没有加载，同样进行类加载，如果加载了，则进行内存分配
    类加载：
        根据全限定名称使用二进制流加载class文件
        将二进制字节流代表的静态存储结构转化为方法区的运行时数据结构
        在内存中生成一个代表这个类的Class对象，作为方法区这个类的各种数据的访问入口
    链接：链接又可以细分为验证、准备、解析
        验证：主要验证class文件是否正确，例如版本是否对应，是否符合语法等等
        准备：为static设置初始值并分配内存
        解析：符号引用转为直接引用（对象属于哪个类的实例、hash码、对象的GC年龄等）
    初始化：
        为static变量赋值的过程
        每个类都有一个初始化锁LC，进程获取LC，这个操作会导致当前线程一直等待，直到获取到LC锁
        
2、内存分配
    指针碰撞和空闲列表。
    指针碰撞：内存是连续的，年轻代使用，使用该种分配方式的垃圾回收器：Serial和ParNew收集器
    空闲列表：内存地址不连续，老年代使用，使用该种分配方式的垃圾回收器：CMS和Mark-Sweep收集器
    分配安全：TLAB和CAS，TLAB是指会给每个线程分配缓冲区，首先在本线程的缓冲区内分配，避免安全问题，如果缓冲区满了，就使用CAS进行分配
    
3、销毁过程
    回收状态：可达状态、不可达状态、可恢复状态
    如果一个对象没有引用，在标记时，会判断当前对象是否重写了finalize方法或者已经执行过该方法
        如果没有重写或者已经执行过，那么直接回收
        如果有重写且没有执行过该方法，则执行finalize方法，并将对象放入一个队列中
    消费队列，判断该对象上是否存在强引用
        如果存在，移除队列
        如果不存在，则进行回收

4、访问方式
    句柄访问：
        本地变量表中存储的是句柄池中句柄的指针，句柄指向堆中对象实例数据的指针和一个指向方法区中对象类型的指针。
        句柄访问的优点是稳定，因为如果对象发生移动，则只需要改变句柄中指向堆中实例数据的指针即可。
    直接指针访问：
        虚拟机栈中本地变量表存储的是直接指向堆中对象的指针，对象中又包含实例数据和类型指针等信息。
        直接指针访问的优点是，访问速度快，节省了一次指针定位的开销。
5、为什么要内存担保
    当新生代放不下时，会发生年轻代GC，将存活的对象放入老年代。

# 垃圾收集算法、垃圾收集器概述
1、收集算法
    标记清理算法：分为标记和清理两个步骤，在标记完成后统一清理掉所有被标记的对象，优点是效率高，缺点是存在内存碎片
    标记整理算法：分为标记、清理、整理三个步骤，在标记完成后统一清理掉所有被标记的对象，最后在将存活的对象移动到一端。优点是没有磁盘碎片、缺点是效率低
    复制收集算法：将内存化为两等分，每次使用其中一块，当垃圾收集时，将存活的对象复制到另一块区域，然后全量清除当前区域。优点是效率高，没有磁盘碎片，缺点是磁盘利用率低
    分代收集算法：根据强弱分代假说，将内存区域分成年轻代和老年代，根据不同代对象的特点选择不同的垃圾收集算法

2、垃圾收集器
    （1）串行垃圾收集器
        年轻代serials：串行收集，单线程执行，使用复制收集算法，收集期间需要STW，停顿时间长，但是对于单核CPU来说，避免了上下文切换，效率更高
        老年代serials old：串行收集，单线程执行，使用标记整理算法
    （2）并行垃圾收集
        吞吐量优先：
            年轻代parallel scavenge：采用复制算法，吞吐量优先
            老年代parallel old：采用标记整理算法，吞吐量优先
        响应时间优先：
            年轻代parnew：serial收集器的多线程版本
            老年代cms：采用标记清理算法，收集步骤：初始标记、并发标记、重新标记、并发清除；响应时间优先，会产生内存碎片
    （3）整堆垃圾收集
        G1：采用逻辑分代的概念，分2048个region，region分为年轻代region、老年代region、大对象region
            G1整体上采用标记整理算法，局部使用复制算法避免内存碎片
            G1可预测停顿时间，在筛选回收时，根据设置的最大停顿时间收集产出比高的对象
            收集步骤：初始标记、并发标记、最终标记、筛选回收
            堆内存在2G以上的建议使用G1
            G1垃圾回收包括年轻代GC、会和GC、fullgc
        ZGC：ZGC 收集器是一款基于 Region 内存布局的，不设分代的，使用了读屏障、染色指针和内存多重映射等技术来实现可并发的标记-整理算法的，以低延迟为首要目标的一款垃圾收集器。
            ZGC 的核心是一个并发垃圾收集器，这意味着所有繁重的工作都在Java 线程继续执行的同时完成。这极大地限制了垃圾收集对应用程序响应时间的影响。