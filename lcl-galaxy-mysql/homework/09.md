# 题目 01- 请你说一说 MySQL 的锁机制
  按照粒度分，可以分为全局锁、表锁、行锁。
    全局锁会锁住整个数据库，主要是在做整库逻辑备份时会使用，但是如果使用MVCC可以避免。
    表锁分为读锁、写锁、元数据锁，读锁又称为共享锁，写锁又称为独占锁，元数据锁是在对数据结构发生变更使用
    行锁：全局锁和表锁都是mysqlserver层实现的，行锁是innodb存储引擎实现的，有记录锁、间隙锁、临界锁、插入间隙锁
  除了上线的锁以外，为了平衡表锁和行锁，提高效率，又引入了间隙锁，有读间隙读锁、间隙写锁

  死锁：
    组成死锁的四个必要条件：
        一个资源是能被独占
        操作不结束，对于持有的资源不释放
        获取资源获取不到时，一直阻塞等待
        形成循环等待
    在数据库中发生死锁的场景：
        多个事务对数据做变更时，先后顺序颠倒，导致形成互相等待
        多个事务使用条件走的不同索引，但是这两个索引对应聚簇索引数据的顺序刚好相反，形成循环等待
    排查：
    行锁是通过在索引树上加锁完成锁定的

  分析：delete from tt where uid = 666 ;
    如果 uid 是主键，在聚簇索引上加记录锁
    如果 uid 是唯一索引，在uid索引和聚簇索引上加记录锁
    如果 uid 是非唯一索引
        如果是读已提交：在 uid 索引和聚簇索引加记录锁
        如果是可重复读：在 uid 索引加临界锁，在聚簇索引加记录锁
    如果 uid 不是索引，在聚簇索引全量加锁，但是mysql做了优化，如果经过mysqlserver过滤后数据不满足，会将不满足数据的锁释放掉
# 题目 02- 请你说一说 MySQL 的 SQL 优化
  1、批量插入时使用预执行
  2、使用索引，如果可以，尽量使用主键索引
  3、避免索引失效（不要使用不等号、运算符、like时百分号、数据类型转换）
  4、连接查询避免出现笛卡尔积
  5、如果可以使用覆盖索引尽量使用覆盖索引，不要返回大数据量
  6、更新避免范围更新