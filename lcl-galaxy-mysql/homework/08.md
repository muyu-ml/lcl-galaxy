# 题目 01- 完成 ReadView 案例，解释为什么 RR 和 RC 隔离级别下看到查询结果不一致

1. 案例 01- 读已提交 RC 隔离级别下的可见性分析

目标：事务2在第一次读取数据后，如果事务1更改了数据，事务2可以查询到新的数据
操作步骤：
    前置操作，将两个session的事务隔离级别改为 RC：set session TRANSACTION ISOLATION LEVEL read committed; show variables like '%tx_isolation%';
    
（1）事务1：开启事务：BEGIN;
（2）事务2：开启事务：BEGIN；
（3）事务2：查询数据：select tenant_name from tenant_info where id = '5'; -- 值为tx0001
（4）事务1：更新数据：update tenant_info set tenant_name = 'tx002' where id = '5';
（5）事务1：提交事务：COMMIT;
（6）事务2：查询数据：select tenant_name from tenant_info where id = '5'; -- 值为tx002
实践过程：如操作步骤
结论：在RC隔离级别下，Readview是在每一次查询时都会生成，因此在后续查询时会使用新的readview去查看undolog，查看哪个数据自己可见，因此数据会发生变化


2. 案例 02- 可重复读 RR 隔离级别下的可见性分析

目标：事务2在第一次读取数据后，如果事务1更改了数据，事务2查询结果不变
操作步骤：
    （1）事务1：开启事务：BEGIN;
    （2）事务2：开启事务：BEGIN；
    （3）事务2：查询数据：select tenant_name from tenant_info where id = '5'; -- 值为tx0001
    （4）事务1：更新数据：update tenant_info set tenant_name = 'tx002' where id = '5';
    （5）事务1：提交事务：COMMIT;
    （6）事务2：查询数据：select tenant_name from tenant_info where id = '5'; -- 值仍为tx0001
实践过程：如操作步骤
结论：在RR隔离级别下，Readview是在第一次查询时生成，因此在后续查询时仍然使用第一次查询生成的readview，可见数据不会发生变化

# 题目 02- 什么是索引？
索引是为了更快的查询
优点：查询效率高
缺点：占用磁盘空间
索引分类有哪些？特点是什么？
    hash索引：在mysqlserver层又hash索引，类似于缓存；在innodb中，有自实行hash索引，如果对应的是聚簇索引，则value是数据的指针，如果对应的非聚簇索引，value为聚簇索引的指针
    聚簇索引：叶子结点是数据，如果表存在主键，则主键即为聚簇索引，如果没有主键，第一个非空的唯一索引即为聚簇索引，如果也没有，则会使用默认的rowid作为聚簇索引
    非聚簇索引：叶子节点为聚簇索引的指针
        唯一索引：索引值具有唯一性
        组合索引：多个列创建的组合索引
        全文索引：可以做分词和搜索，对于中文支持不够好，建议使用solr或ES
        覆盖索引：指查询返回的列都在索引树上，不需要再回表
        前缀索引：对列的指定前几位创建索引
    
索引创建的原则是什么？
    常用的查询条件、排序、分组等列建议创建索引
    使用区分度大的列创建索引
    建议使用组合索引
    禁止随意创建索引，导致索引过大
有哪些使用索引的注意事项？
    最好使用聚簇索引，避免回表
    避免索引失效：使用不等于、or、 not in、函数、类型转换等
    建议使用组合索引
    
如何知道 SQL 是否用到了索引？
    使用explain查看执行计划，看type列，如果是const、eq_ref、ref、range都是用到了索引，如果是index，说明没有用到索引，扫描了整个索引树，如果是All，则是全表扫描

请你解释一下索引的原理是什么？【重点】
    索引是B+数结构，聚簇索引的非叶子结点存储的是索引，叶子结点存储的是具体的数据；非聚簇索引的非叶子结点存储的是索引值，叶子结点存储的是聚簇索引的指针。
    查询时，首先会选择合适的索引，从跟结点向下查找，最终找到或找不到数据。
    如果是返回查询，找到数据后，由于B+树的叶子结点是用双向指针连接，因此可以向前或向后查找数据，不需要在通过父节点查找

清楚为什么要用 B+Tree
    B+树的非叶子结点只存指针，不存数据，对比B树来说，相同的数据，树高会较低，查询效率更高
    B+树的叶子结点使用双向指针连接，可以更好的支持范围查询


# 题目 03- 什么是 MVCC？
MVCC主要是有Undolog版本链和使用Readview查看数据可见性的一种并发版本控制的实现。
对于同时刻多条数据变化，如果保证在一个节点查询时所有的数据都是处于一个一致性的状态，主要可以使用LBCC和MVCC来解决。
每一行数据的列可以分为隐藏列和可见列，可见列是我们自己创建的列，隐藏列是数据库自动创建的不可见的列，包括事务id、回滚事务id等，使用回滚事务id和事务id就能组成一条undolog版本链
Readview是数据库中的一张表，活跃事务下限（活跃最小事务id）、活跃事务上限（活跃最大事务id+1）、创建该readview的事务id、当前活跃的事务id集合
当去读取一条数据时，拿着readview去判断，如果可见，则返回，不可见，则使用undolog版本链继续判断
可见性判断：
    如果该条数据的事务id小于readview的活跃事务下限，说明在创建该readview之前已经有了该版本的数据，可见
    如果该条数据的事务id大于等于readview的活跃事务上限，说明在创建该readview时还没有该版本的数据，不可见
    如果该条数据的事务id在readview的活跃事务下限和上限之间：
        判断该条数据的事务id是否与创建readview的事务id相等，如果相等，则说明这条数据和reaview是在同一个事务中创建的，可见
        如果不等，查看该事物id是否在readview的活跃事务列表中存在的
            如果不存在，说明该事务已经提交，可见
            如果不存在，说明该事务仍然处于活跃状态，不可见
对于RC和RR事务隔离级别来说，主要是Readview的生成时机不同，RC是在事务中的每一次查询都会生成一个Readview，RR是在事务中的第一次查询时生成Readview，该事务的后续查询都是用这一个Readview